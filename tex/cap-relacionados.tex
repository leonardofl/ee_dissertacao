
\chapter{Trabalhos relacionados}
\label{cap:relacionados}

Neste capítulo apresentaremos trabalhos relacionados e ferramentas utilizadas pela comunidade referentes à implantação automatizada de serviços. 

A automação do processo de implantação requer uma descrição formal do sistema a ser implantado, com as informações necessárias para sua implantação. Portanto, um dos aspectos fundamentais de um processo de implantação automatizado é a linguagem de configuração utilizada para definir o processo de implantação. Essa linguagem pode ser procedimental~\cite{Dolstra2005Configuration} ou declarativa~\cite{Magee1996Dynamic, Balter1998Olan}. Outro aspecto relevante é o escalonamento de recursos computacionais para os serviços a serem implantados, o que pode ser feito, por exemplo, com o auxílio de sistemas de computação em grade~\cite{Watson2006Dynasoar}.

Antes de instalar um serviço é preciso configurar adequadamente o sistema operacional e a plataforma na qual o serviço será implantado. No uso de ferramentas como Chef\footnote{\url{www.opscode.com/chef}}, Capistrano\footnote{\url{github.com/capistrano}} e Nix~\cite{Dolstra2005Configuration}, os usuários devem escrever \textit{scripts} que implementam o processo de configuração do ambiente e a implantação do serviço. No caso do Chef, um script configura a máquina na qual o serviço é instalado, enquanto que o Capistrano possibilita a coordenação da implantação de serviços em diferentes nós. Com as expressões Nix, é possível também unificar a especificação da implantação com o \textit{build} da aplicação em um único script, possibilitando a edição parametrizada de arquivos de configuração da aplicação em função do local de implantação. 

A abordagem procedimental permite ao usuário especificar a implantação de praticamente qualquer tipo de sistema, mas normalmente requer especialização de seus usuários, pois todos os detalhes do processo devem ser especificados. Esses \textit{scripts} de implantação também deveriam ser desenvolvidos com o mesmo rigor do código da aplicação, inclusive com o uso de testes automatizados~\cite{Humble2011Continuous}. O descumprimento dessa recomendação torna o processo de implantação pouco robusto e até mesmo não confiável. Uma alternativa que evita essa sobrecarga no processo de desenvolvimento é o uso de sistemas especializados na implantação de determinados tipos de aplicações e que recebam, como entrada, uma simples especificação declarativa do sistema a ser implantado.

Um exemplo de abordagem declarativa é uso de Linguagens de Descrição Arquitetural (ADLs), como a Darwin~\cite{Magee1996Dynamic}. ADLs são uma evolução do conceito de Linguagens de Interconexão de Módulo (MILs), conforme proposto por De Remmer e Kron~\cite{DeRemer1976Programming}. A motivação dos autores da MIL era contribuir com novas formas de se produzir software de grande porte, diferenciando essa atividade da programação de pequenos algoritmos. Para isso, propuseram uma Linguagem de Interconexão de Módulos, que objetiva incentivar a estruturação do sistema antes de sua implementação, além de incentivar a descrição da interconexão entre módulos sem que fosse preciso a descrição interna dos módulos. 

A linguagem Darwin se foca nos aspectos estruturais de sistemas distribuídos, descrevendo a conexão entre os módulos do sistema, mas sem descrever implementações ou sequências de interações entre os módulos. Em nosso trabalho, também descrevemos o sistema a ser implantado através de sua descrição estrutural, uma vez que é esse o aspecto necessário para que se possa automatizar o processo de implantação. 

Magee e Kramer demonstraram a utilidade prática da linguagem Darwin ao utilizá-la de forma integrada a componentes CORBA~\cite{Magee1997Corba}, padrão de componente dominante no mercado à época. Darwin possui também um ambiente de execução, Regis~\cite{Magee1994Regis}, que realiza a implantação dos sistemas descritos em Darwin. Regis possui duas políticas de distribuição de programas por estações de trabalho. A primeira é o mapeamento definido pelo usuário de forma estática, abordagem não apropriada para ambientes de computação em nuvem. A segunda opção de política é a alocação automática em função da carga na CPU das estações de trabalho, não havendo flexibilidade para a consideração de outros recursos, como espaço em disco ou memória, por exemplo. Uma similaridade entre Regis e o \ee\ é o uso do middleware para o envio de mensagens contendo referências remotas dos componentes implantados para que eles possam estabelecer ligações dinâmicas entre si.

Olan~\cite{Balter1998Olan} é um ambiente para a descrição, configuração e implantação de aplicações distribuídas em ambientes heterogêneos, e que também utiliza uma ADL própria. Baseando-se na entrada descrita na ADL, Olan gera scripts de Configuração de Máquina, que definem a execução do processo de implantação dos componentes no ambiente distribuído e do ajuste dos canais de comunicação entre esses componentes. A abordagem de gerar um script de configuração a partir de uma especificação declarativa é também implementada pelo \ee. A ADL de Olan também possibilita a especificação de restrições sobre a localização da implantação do componente, porém sem flexibilidade para a adoção de estratégias dinâmicas de alocação de nós.

Apesar de os trabalhos sobre Darwin e Olan já falarem sobre software de ``grande porte'', o que entendia-se por grande porte já se alterou significativamente desde a época em que esses trabalhos foram feitos. Uma evidência dessa diferente percepção de escala são os exemplos de aplicações fornecidos no artigo sobre Olan, em que se fala sobre componentes muito granulares, como pedaços de interfaces gráficas, e que não consideram possíveis falhas de comunicação que são comuns na Internet. Além disso, os próprios autores do artigo sobre Olan admitem que não se preocuparam com questões de desempenho. Conforme visto no capítulo sobre Computação em Grande Escala, hoje há novos desafios e requisitos que precisam ser considerados na construção de qualquer software de grande escala.

Os trabalhos anteriores apresentam abordagens simples para o problema da distribuição dos componentes implantados pelas máquinas disponíveis. Já o trabalho de Watson et al., apresenta uma abordagem mais completa para esse problema com o uso de grades computacionais~\cite{Watson2006Dynasoar}. O foco da solução apresentada está em escolher dinamicamente o provedor de infraestrutura e a máquina em que um serviço web deve ser implantado considerando os requisitos não-funcionais do serviço web. Isso é realizado não somente para a primeira implantação do serviço web, mas também para as replicações que ocorrem quando as instâncias existentes não conseguem mais atender aos requisitos não-funcionais. Uma desvantagem dessa abordagem é a carga adicional gerada pela análise dos requisitos não-funcionais a cada troca de mensagens efetuada pelos serviços implantados.

Embora o trabalho de Watson et al. avance na problemática da distribuição dos serviços, nenhum dos trabalhos analisados considera as potencialidades e desafios dos ambientes de computação em nuvem, que oferecem serviços de infraestrutura para a gerência de recursos virtualizados. Portanto, em nossa pesquisa consideramos o que foi aprendido nesses estudos e procuramos dar um passo além, ao explorar como o ambiente de computação em nuvem pode trazer benefícios ao processo de implantação, bem como ao considerar as restrições que esses ambientes impõem, como a falta de previsibilidade dos endereços das máquinas em tempo de configuração do serviço e as falhas no serviço oferecido pela plataforma de nuvem.

Uma tendência atual para se atingir os objetivos de uma implantação simples, rápida e automatizada é a utilização de serviços de computação em nuvem que oferecem Plataforma como um Serviço (PaaS), que se encarregam não só da implantação da aplicação, como também do processo de criação e configuração do ambiente. O Cloud Foundry\footnote{\url{http://www.cloudfoundry.com/}} é um PaaS de código aberto, podendo ser instalado na infraestrutura de uma organização para a oferta de serviços a clientes internos ou externos. O Cloud Foundry suporta uma grande diversidade de linguagens, arcabouços e bancos de dados a serem utilizados pela aplicação. Operadores do Cloud Foundry podem configurá-lo para utilizar diferentes provedores de Infraestrutura como um Serviço (IaaS), o que gera um desacoplamento nas escolhas de IaaS e PaaS, o que será também adotado no \ee.

O Cloud Foundry se foca na implantação de aplicativos web, e não na implantação de composições de serviços. Durante a implantação de uma aplicação pelo Cloud Foundry, o operador pode realizar ligações entre a aplicação e serviços tipicamente utilizados por aplicativos web, como bancos de dados, que serão criados e configurados pela própria plataforma. Essa escolha deve ser feita dentro de um conjunto fechado de serviços suportados pela plataforma (ex: MySQL, MongoDB, etc.). No entanto, ao se implantar composições de serviços é preciso estabelecer também ligações entre os próprios serviços sendo implantados, cenário não considerado pelos atuais provedores de PaaS.


