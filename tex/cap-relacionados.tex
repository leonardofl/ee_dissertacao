
\chapter{Trabalhos relacionados}
\label{cap:relacionados}

Nesta seção apresentaremos estudos relacionados à implantação automatizada de serviços e sistemas. Apresentaremos também ferramentas utilizadas pela comunidade com o objetivo de automatizar a implantação de sistemas.

\fabio{Fazer introduções para as ``áreas''; dar visão geral das áreas de estudo; De cara este parágrafo parece muito detalhista}

O trabalho de Dolstra et al.~\cite{Dolstra2005Configuration} aborda o problema da falta de processos automatizados para a implantação de serviços. Os autores apresentam a linguagem Nix para a edição automatizada de arquivos de configuração (ex: httpd.conf do Apache), integrando assim os processos de \emph{build}, implantação e configuração de serviços. Os autores mostram como essa abordagem possibilita a implementação das seguintes funcionalidades: \emph{roll-back,} atualização dinâmica, composições de configurações, implantações paralelas e implantação distribuída. O suporte a \emph{roll-back} é feito com o gerenciamento de links simbólicos para os arquivos de configuração. Caso na nova versão apenas os arquivos de configuração sejam alterados, a mesma técnica possibilita a atualização dinâmica, isto é, a nova versão do sistema é posta em produção sem que seja preciso reiniciar o sistema. A linguagem Nix possibilita a especificação de apenas um fragmento de um arquivo de configuração, o que evita que as configurações de um serviço sobrescrevam as configurações de outro serviço. Uma expressão Nix pode ser escrita em função da variável \emph{productionServer}, que diz se o sistema está sendo implantado em um ambiente de produção ou em um ambiente de testes. O uso da variável \emph{productionServer} pode ser combinado com outro recurso da linguagem Nix: o de especificar em que máquina o serviço será implantado.

A utilização da variável \emph{productionServer} evita o desenvolvimento e a manutenção de diferentes scripts de implantação similares. Essa prática é também recomendada por Humble e Farley, no livro Continous Delivery~\cite{Humble2011Continuous}, que afirma que o script de implantação deve ser o mesmo para todos os ambientes, pois sua utilização frequente pelos desenvolvedores dá mais confiança aos operadores sobre a qualidade do script.

Embora as gerências de build, implantação e configuração possam ser unificadas em uma só ferramenta, como sugerido por Dolstra et al., consideramos que ainda são problemas separados. Nosso trabalho aborda a gerência de implantação, e consideramos que a configuração é parte integrante do artefato a ser implantado, e que a gerência das configurações está em uma camada anterior ao processo de implantação. Dessa forma, não podemos tratar o problema do roll-back e da atualização online da mesma forma que Dolstra et al. Reconhecemos que a composição de configurações é um problema relevante quando estamos em um ambiente mais genérico, em que qualquer tipo de sistema pode ser implantado. No entanto, acreditamos que ao fechar o escopo dos tipos de artefatos implantáveis, como é o nosso caso, esse problema é diminuído sensivelmente. Por fim, assim como a linguagem Nix, também nos preocupamos com a implantação distribuída dos sistemas, mas utilizaremos uma abordagem mais apropriada para o ambiente de computação em nuvem, em que os endereços das máquinas podem não ser conhecidos anteriormente ao processo de implantação.

O trabalho de Watson et al.~\cite{Watson2006Dynasoar} refere-se à implantação automatizada de serviços web em ambientes de grades computacionais. A principal contribuição desse trabalho é a separação entre provedores de serviços web e provedores de infraestrutura (\emph{host providers}). Para os efeitos do trabalho de Watson et al., um ambiente de grade é similar a um ambiente de nuvem, com a principal diferença que na nuvem há uma forte ênfase no fato de que os recursos são virtualizados. O foco da solução apresentada está em escolher dinamicamente o provedor de infraestrutura e a máquina em que um serviço web deve ser implantado considerando os requisitos não-funcionais do serviço web. Isso é realizado não somente para a primeira implantação do serviço web, mas também para as replicações que ocorrem quando as implantações existentes não conseguem mais atender aos requisitos não-funcionais, que são declarados no cabeçalho do envelope SOAP.

Uma desvantagem do método proposto por Watson et al. é a sobrecarga gerada pelo processamento do envelope SOAP a cada troca de mensagem com o serviço, pois isso envolve verificar no envelope quais são os requisitos e monitorar o desempenho atual das instâncias implantadas. Esse segundo passo, o monitoramento, não é tratado pelo artigo. Em contraste, nossa arquitetura é utilizada somente em tempo de implantação, não afetando a operação ordinária do serviço. O estudo de Watson et al. também não considera a complexidade inerente à replicação de serviço devido à utilização compartilhada de bases de dados pelas diferentes instâncias do serviço.  Em nosso trabalho não abordaremos a questão da duplicação de serviços. Mas consideramos que nossa arquitetura fornece os serviços necessários para que uma camada superior do sistema possa realizar esse gerenciamento de forma mais fácil.

A automação do processo de implantação requer uma descrição formal do sistema a ser implantado, com as informações necessárias para sua implantação \fabio{Mais frases conceituais como essa, e não picuinhas}. Essa descrição em alguns casos é procedimental, como nas receitas Chef e do Capistrano, casos em que o usuário deve descrever em um script o passo a passo necessário para a instalação do software. Mas também há abordagens declarativas, relacionadas ao conceito de Linguagens de Descrição Arquitetural (ADLs), em que o usuário descreve apenas o que precisa ser instalado, e não como deve ser a instalação. Veremos a seguir um breve histórico das ADLs, que possibilitam a implantação automatizada baseada em especificações declarativas.

O conceito de ADL é uma evolução das Linguagens de Interconexão de Módulo (MILs), conforme proposto por De Remmer e Kron~\cite{DeRemer1976Programming}. A motivação dos autores era contribuir com novas formas de se produzir software de grande porte, diferenciando essa atividade da programação de pequenos algoritmos. Para isso, propuseram uma Linguagem de Interconexão de Módulos, que objetiva incentivar a estruturação do sistema antes de sua implementação, além de incentivar a descrição da interconexão entre módulos sem que fosse preciso a descrição interna dos módulos. 

Um exemplo de ADL é a Darwin, proposta por Magee e Kramer, uma linguagem declarativa para a especificação da estrutura de sistemas distribuídos cujos componentes utilizam diversos mecanismos de interação~\cite{Magee1996Dynamic}. Os autores destacam que enquanto sistemas são descritos de acordo seus aspectos \emph{estruturais}, \emph{computacionais} e \emph{interativos}, a linguagem Darwin foca nos aspectos estruturais, o quer dizer que Darwin descreve quais módulos estão conectados em quais outros, mas não descreve nem o que fazem os módulos, nem que mensagens eles trocam. A MIL anteriormente descrita e linguagens mais modernas como BPEL não descrevem o aspecto de computação, mas descrevem a estrutura e a interação entre os módulos. Esse ponto merece destaque, pois o aspecto estrutural é a descrição que possibilita e que basta para a automação do processo de implantação. Segundo Magee e Kramer~\cite{Magee1994Regis}, essa separação nos aspectos estruturais, computacionais e interativos é crucial no gerenciamento da complexidade de grandes programas concorrentes e distribuídos.

Magee e Kramer demonstraram a utilidade prática da linguagem Darwin ao utilizá-la de forma integrada a componentes CORBA~\cite{Magee1997Corba}, padrão de componente dominante no mercado à época. Darwin possui também um ambiente de execução, Regis~\cite{Magee1994Regis}, que realiza a implantação dos sistemas descritos em Darwin, e que possui algumas similaridades com nosso trabalho para além do uso de uma ADL. Regis possui duas políticas de distribuição de programas por estações de trabalho, sendo uma o mapeamento definido por usuário, e outra a alocação automática em função da carga na CPU das estações de trabalho. Regis envia aos componentes instanciados mensagens contendo referências remotas a outros componentes para que esses componentes possam estabelecer ligações dinâmicas entre si. Uma diferença importante entre nosso trabalho e o trabalho sobre Darwin, é que Magee e Kramer concentram esforços em possibilitar que a composição de componentes seja alterada em tempo de execução, o que não será o foco de nosso trabalho.

Similar ao trabalho sobre Darwin, Balter et al.~\cite{Balter1998Olan} apresentam Olan, um ambiente para a descrição, configuração e implantação de aplicações distribuídas em ambientes heterogêneos, e que também utiliza uma ADL própria. Os autores definem implantação como a distribuição e instalação de componentes em nós e o ajuste dos canais de comunicação entre os componentes, de acordo com as propriedades de interconexão contidas na descrição arquitetural. Baseando-se na entrada descrita na ADL, Olan gera um script de Configuração de Máquina, que define a execução do processo de implantação dos componentes no ambiente distribuído. A ADL de Olan também possibilita a especificação de restrições sobre a localização da implantação do componente.

O ambiente Olan é projetado para resolver outros problemas também, como a comunicação entre componentes de tecnologias heterogêneas, composição de componentes e conciliação entre interfaces heterogêneas. Esses problemas são resolvidos com o uso de \emph{conectores}, componentes especiais que mediam a comunicação entre outros componentes. Consideramos, porém, que os problemas endereçados pelo uso de conectores são independentes da questão principal do nosso trabalho: a automação do processo de implantação.

Apesar de os trabalhos sobre Darwin e Olan já falarem sobre software de ``grande porte'', o que entendia-se por grande porte já se alterou significativamente desde a época em que esses trabalhos foram feitos. Uma evidência dessa diferente percepção de escala são os exemplos de aplicações fornecidos no artigo sobre Olan, em que se fala sobre componentes muito granulares, como pedaços de interfaces gráficas. Além disso, os próprios autores do artigo sobre Olan admitem que não se preocuparam com questões de desempenho. Como vimos na seção Computação em Grande Escala, hoje há novos desafios e requisitos que precisam ser considerados na construção de qualquer software de grande escala. \fabio{Falar também que eles pensavam mais em redes locais doq internet}

\section{Ferramentas}