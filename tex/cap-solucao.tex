
\chapter{Solução Proposta}
\label{cap:solucao}

Considerando os requisitos de coreografias de serviços web, de uso da computação em nuvem e de sistemas em grande escala, definimos um arcabouço para a implantação de coreografias de serviços web denominado \ee. Os serviços oferecidos pelo nosso arcabouço se integram ao Ambiente Integrado de Desenvolvimento e Execução CHOReOS, que visa fornecer todo o processo de desenvolvimento, implantação e governança de coreografias de serviços web. Para a implementação do arcabouço Enactment Engine contribuíram diretamente os seguintes colegas do grupo de pesquisa: Daniel Cuckier, Carlos Eduardo do Santos, Felipe Pontes, Alfonso Diaz, Nelson Lago e Paulo Moura. \gerosa{Será que precisa dizer? Não poderia estar nos agradecimentos?}

Neste capítulo descrevemos a arquitetura do arcabouço proposto, incluindo os pontos de extensão previstos. Destacamos os aspectos cobertos e não cobertos dos requisitos de sistemas de grande escala. Apresentamos também o estado atual da implementação do arcabouço, assim como os resultados experimentais sobre sua escalabilidade obtidos até o momento.

\section{Arquitetura}
\label{sec:arquitetura}

As funcionalidades do Enactment Engine são expostas como serviços, sendo a principal operação disponível a encenação de coreografias. Para executar essa operação, o Enactment Engine recebe uma descrição arquitetural de baixo nível da coreografia, que contém as URLs para seus artefatos implantáveis. Com base nessa descrição, o Enactment Engine implanta os artefatos em diversos nós nas nuvens das diferentes organizações participantes da coreografia. O cliente do Enactment Engine recebe como resposta dados que descrevem em que nó cada serviço da coreografia foi implantado.

Para realizar a implantação da coreografia de maneira distribuída pelas várias organizações participantes da coreografia, o Enactment Engine é composto por  componentes que são instanciados nas infraestruturas dessas organizações. A relação de uso entre esses componentes é exibida na Figura~\ref{fig:ee_componentes}. Os componentes Choreography Deployer e Deployment Manager são fornecidos pelo próprio arcabouço. Os componentes Chef Client e Chef Server são partes do Chef, uma solução livre para a gerência de configuração de software. Por fim, o componente Cloud Gateway é também fornecido por terceiros, com opções correspondentes às diferentes soluções para a gerência de máquinas virtuais, como , por exemplo, o serviço EC2 da Amazon. A seguir, descrevemos brevemente cada um dos componentes do arcabouço.

\begin{figure}[!h]
  \centering
  \includegraphics[width=.80\textwidth]{components.pdf} 
  \caption{Arquitetura do arcabouço \ee}
  \label{fig:ee_componentes} 
\end{figure}

\begin{description}

\item [Cloud Gateway:]

Este componente cria e destrói máquinas virtuais em uma infraestrutura de computação em nuvem. Neste contexto, essas máquinas virtuais são também chamadas \emph{nós}. Esse componente é utilizado pelo Deployment Manager, que decide quando criar ou destruir os nós. Uma instância do Deployment Manager é configurada de acordo com o Cloud Gateway a ser utilizado. Nativamente são utilizados como Cloud Gateway o serviço EC dos Web Services da Amazon ou uma instalação do OpenStack. Outras tecnologias de nuvem ou virtualização são utilizadas mediante extensão do Node Pool Manager.

\item [Chef Server:]

Em um sistema gerenciado pelo Chef, as configurações de software de um nó são especificadas por meio de ``receitas''. As receitas especificam configurações do sistema operacional (exemplo: instalar o pacote Java em um sistema Debian), instalação e configuração de middlewares (exemplo: instalar o Tomcat), assim como a instalação de um serviço final implantado sobre o middleware já configurado (exemplo: um web service). Essas receitas e as associações entre receitas e nós são armazenadas no Chef Server. Os operadores do Chef atualizam essas configurações diretamente pela interface gráfica do Chef Server ou pelo uso do Knife, uma ferramenta de linha de comando que se comunica com o Chef Server por meio de uma API REST. Na arquitetura do Chef, a máquina onde o operador utiliza o Knife é denominada ``workstation''. A arquitetura de um sistema gerenciado pelo Chef pode ser observada na Figura~\ref{fig:chef_arquitetura}.

\item [Chef Client:]

Em cada nó gerenciado pelo Chef é instalado um programa denominado Chef Client, que utiliza a API REST do Chef Server para obter as receitas relacionadas ao nó e assim atualizar suas configurações de software. O processo de instalação do Chef Client no nó é denominado ``bootstrap'', e é executado por meio de um comando do Knife, que se conecta por SSH na máquina para realizar a instalação do Chef Client e suas dependências.

\item [Deployment Manager:]

Implanta os serviços em um ambiente de nuvem associado a uma organização. Através de uma operação REST, o Deployment Manager recebe a especificação de um serviço e seleciona um nó adequado para sua implantação, possivelmente considerando os requisitos não-funcionais do serviço. O Deployment Manager converte a especificação recebida em uma receita Chef que implementa o processo de instalação do serviço. Após gerar a receita, o Deployment Manager a armazena no Chef Server e, também utilizando o Chef, cria uma associação entre essa receita e o nó selecionado. Utilizando outra operação REST do Deployment Manager pode-se requisitar que um determinado nó seja atualizado de acordo com as receitas a ele relacionadas. Essa divisão do processo em duas chamadas ao Deployment Manager é adotada para evitar a sobrecarga de execuções desnecessárias do Chef Client.

\item [Choreography Deployer:]

O Choreography Deployer expõe uma API REST de operações que automatizam a implantação de coreografias de serviços web. O cliente do Choreography Deployer fornece uma especificação declarativa da coreografia composta por uma descrição arquitetural da coreografia e da localização dos artefatos a serem implantados. Baseado nessa especificação, o Choreography Deployer coordena invocações aos Deployment Managers implantados nas diferentes organizações que participam da coreografia. Após a implantação dos serviços, para cada par de serviços que se comunicam na coreografia, o Choreography Deployer informa ao serviço consumidor a localização do serviço provedor.

\end{description}

\begin{figure}[!h]
  \centering
  \includegraphics[width=.80\textwidth]{chef.pdf} 
  \caption{Arquitetura do Chef}
  \label{fig:chef_arquitetura} 
\end{figure}

A execução do Chef Client é demorada, tipicamente alguns minutos, dependendo do que está sendo instalado. Considerando que vários serviços podem ser implantados em um mesmo nó, a implantação da coreografia seria muito mais demorada caso cada invocação ao Deployment Manager resultasse em um pedido de atualização do nó onde o serviço deve ser implantado. Por isso, cabe ao Choreography Deployer a decisão de quando os nós são atualizados. Com isso, para cada nó, pode-se executar o Chef Client apenas uma vez para cada coreografia encenada. Essa otimização torna o sistema mais escalável. 

O diagrama de implantação da Figura~\ref{fig:ee_distribuicao} mostra como se distribuem os componentes do arcabouço Enactment Engine. Cada organização do diagrama está relacionada a uma instância de um sistema de nuvem privada (Open Stack, por exemplo), ou a uma conta de um provedor de nuvem pública (Amazon, por exemplo). A infraestrutura de cada organização deve possuir os seguintes componentes: um Cloud Gateway, um Chef Server e um Deployment Manager. 

\begin{figure}[!h]
  \centering
  \includegraphics[width=1\textwidth]{ee_deployment.pdf} 
  \caption{Distribuição da implantação dos componentes do Enactment Engine}
  \label{fig:ee_distribuicao} 
\end{figure}

Um exemplo de ambiente distribuído com várias organizações é mostrado no diagrama da Figura~\ref{fig:ee_exemplo_distribuicao}. Nesse diagrama, existem três organizações: Linagora, Thales e USP. Cada organização corresponde ao nó ``organization'' do diagrama genérico de implantação (Figura~\ref{fig:ee_distribuicao}). Esse último diagrama também destaca o fato de que organizações podem tanto usar suas próprias nuvens privadas, quanto alguma nuvem pública, como a da Amazon. Caso uma organização deseje utilizar mais de um sistema de nuvem, ela deverá ser modelada em nosso arcabouço como várias organizações diferentes. Por exemplo, se a organização USP deseja utilizar uma nuvem privada com o OpenStack e o serviços da Amazon, pode-se modelar as seguintes organizações: USP\_OpenStack e USP\_AWS.

\begin{figure}[!h]
  \centering
  \includegraphics[width=.80\textwidth]{ee_exemplo_distribuicao.pdf} 
  \caption{Exemplo de uso do Enactment Engine em diferentes organizações}
  \label{fig:ee_exemplo_distribuicao} 
\end{figure}

Terminamos esta seção com um diagrama de sequência (Figura~\ref{fig:ee_sequencia}) que evidencia detalhes da interação entre os componentes do arcabouço. Esse diagrama ilustra o processo de encenação de uma pequena coreografia de dois serviços, na qual o serviço A é consumidor do serviço B.

\begin{figure}[!h]
  \centering
  \includegraphics[width=.80\textwidth]{sequence.pdf} 
  \caption{Exemplo de implantação de uma coreografia de dois serviços}
  \label{fig:ee_sequencia} 
\end{figure}

O processo de implantação se inicia com duas requisições ao Choreography Deployer: uma para a criação do recurso\footnote{Usamos aqui o termo ``recurso'' em seu sentido usual em arquiteturas REST.} \emph{coreografia} associado à especificação fornecida pelo cliente e outra para a encenação da coreografia. Para cada especificação de serviço contido na especificação da coreografia, o Choreography Deployer requisita a criação de um recurso \emph{serviço} ao Deployment Manager. Para isso, o Deployment Manager cria uma receita Chef que automatiza a instalação do serviço, armazena-a no Chef Server e associa a receita a algum nó por ele selecionado. O Deployment Manager retorna ao Choreography Deployer o recurso \emph{serviço}, contendo a URI de acesso a esse serviço e uma referência ao nó selecionado. Em seguida, o Choreography Deployer requisita ao Deployment Manager a atualização de todos os nós selecionados. Quando o Deployment Manager recebe um pedido de atualização de nó, ele se conecta por SSH a esse nó e executa o Chef Client, que se comunica com o Chef Server para obter as receitas associadas àquele nó e instalar os serviços com base nas receitas obtidas. O Choreography Deployer ainda invoca a operação \emph{setInvocationAddress} do serviço B, informando ao serviço B a URI de acesso do serviço A. Finalmente, o Choreography Deployer devolve ao cliente a representação da coreografia, contendo informações da implantação, especialmente as URIs dos serviços em execução.

Uma observação sobre o diagrama da Figura~\ref{fig:ee_sequencia} é que todas as operação foram dispostas de forma sequencial para facilitar a leitura do diagrama, mas o Choreography Deployer realiza as chamadas de criação dos serviços em paralelo, assim como as chamadas de atualização dos nós e as invocações às operações \emph{setInvocationAddress}.

\section{Descrição Arquitetura da Coreografia}
\label{sec:adl}

O Enactment Engine recebe de seus clientes a especificação da coreografia na forma de uma descrição arquitetural com as informações necessárias e suficientes para que se possa realizar a implantação da coreografia. O Enactment Engine também devolve ao seu cliente informações sobre a implantação da coreografia, em especial as localizações de acesso aos serviços. Essa descrição da coreografia se assemelha às propostas de Linguagens de Descrição Arquiteturais vistas no capítulo de trabalhos relacionados. A nossa ADL consiste na descrição de objetos relacionados entre si seguindo a estrutura de classes apresentada na Figura~\ref{fig:ee_adl}. Em nossa implementação, essa descrição é realizada com representações em XML, que são trocadas entre o Enactment Engine e seu cliente. O Anexo~\cite{anexo:adl_xml} lista exemplos de entrada e de saída em XML do Enactment Engine, bem como o \emph{schema} que define a formatação dos dados em XML.  

\begin{figure}[!h]
  \centering
  \includegraphics[width=.80\textwidth]{adl.pdf} 
  \caption{Estrutura da descrição arquitetural de uma coreografia}
  \label{fig:ee_adl} 
\end{figure}

Apresentaremos agora uma breve descrição sobre cada uma das classes apresentadas no diagrama.

\begin{description}

\item [ServiceSpec:] especificação de um serviço com informações necessárias para que se realize a implantação de um serviço fora do contexto da coreografia.

\item [ServiceDependency:] representa uma dependência entre serviços. Se o serviço A invoca o serviço B, então o serviço A depende do serviço B.

\item [ChorServiceSpec:] especificação de um serviço com informações necessárias para que se realize a implantação de um serviço em uma coreografia.

\item [ChorSpec:] Uma coleção de elementos ChorServiceSpec que especificam uma coreografia.

\item [Service:] contém informações sobre um serviço já implantado.

\item [Choreography:] contém informações sobre os serviços implantados que formam uma coreografia.

\end{description}

Iremos agora detalhar o significado dos atributos das classes já apresentadas:

\begin{description}

\item [Service.name e ServiceSpec.name:] um nome único para o serviço dentro da coreografia.

\item [ChorServiceSpec.owner:] organização que controla a infraestrutura onde o serviço deve ser implantado. Com esse atributo pode-se garantir que serviços sejam instalados em organizações de confiança do fornecedor do serviço, assim como proposto por Watson~\cite{Watson2006Dynasoar}.

\item [ChorServiceSpec.group:] dois serviços especificados no mesmo grupo devem ser implantados no mesmo nó.

\item [ChorServiceSpec.roles:] lista de papéis desempenhados pelo serviço.

\item [ServiceSpec.type:] especifica o tipo de serviço, de acordo com a enumeração ServiceType, que contém os valores SOAP e REST. Com essa informação, o Enactment Engine sabe como acessar a operação setInvocationAddress desses serviços, para que os serviços da coreografia saibam da localização uns dos outros. 

\item [ServiceSpec.artifactType:] o tipo do artefato implantável. Deve corresponder a algum valor da enumeração ArtifactType. Se tipo do artefato for COMMAND\_LINE, o serviço é iniciado com o comando ``java -jar''. Se possui o valor TOMCAT, é simplesmente instalado em um Tomcat em execução. Se for EASY\_ESB, assume-se que se trata de um arquivo de configuração que executará ações em um nó do EasyESB. Se for LEGACY, trata-se de um serviço já acessível pela Internet.

\item [ServiceSpec.codeUri:] a localização do artefato que instalará o serviço. Se o tipo do serviço é LEGACY o valor de codeUri corresponde à URI do serviço já disponível.

Para o artefato COMMAND\_LINE, o atributo codeUri pode apontar para um arquivo jar ou para um tar.gz, que deve ter um jar compactado em sua raiz. O suporte à opção tar.gz é muito importante para que o cliente mantenha a separação entre código executável e configuração de seus serviços. Caso apenas os arquivos jars fossem suportados, o cliente seria obrigado a empacotar as configurações de seu serviço dentro do próprio jar, o que é visto como uma má prática no livro Continous Delivery~\cite{Humble2011Continuous}, que prega que um binário deve ser executável, na medida do possível, em todos os ambientes necessários. Ou seja, gerar um executável para cada plataforma alvo é indesejável. Esse objetivo pode ser atingido com a separação das configurações específicas de cada ambiente em arquivos de configuração. Infelizmente, tal prática não é viável para artefatos do tipo war, que são implantados no Tomcat.

\item [ServiceSpec.port:] a porta TCP utilizada pelo serviço. Obrigatório caso o tipo seja COMMAND\_LINE.

\item [ServiceSpec.endpointName:] o sufixo do endpoint do serviço após sua implantação. Por exemplo, se o serviço é implantado e acessível pela URI http://<IP>:<PORTA>/choreos/service, o endpointName é a string ``choreos/service''. Se o tipo é LEGACY, então endpointName é vazio.

\item [ServiceSpec.version:] a versão do serviço, que será usada pela operação de atualização da coreografia para determinar os serviços que precisam ser re-implantados.

\item [ServiceSpec.resourceImpact:] conjunto de pares chave-valor que especificam os requisitos não-funcionais do serviço. Esses requisitos não-funcionais são utilizados pelo Node Pool Manager para a escolha, se possível, de um nó nuvem que satisfaça esses requisitos.

\item [Service.uri:] URI completa do serviço implantado.

\item [Service.hostname:] hostname do nó em que o serviço foi implantado.

\item [Service.ip:] IP público do nó em que o serviço foi implantado.

\item [Service.nodeId:] ID do nó onde o serviço foi implantado. Este ID possibilita acessar mais informações sobre o nó pelo Node Pool Manager. 

\end{description}

Uma abordagem simples para realizar a ligação entre clientes e seus provedores em uma coreografia é descrever o endereço do provedor em tempo de projeto no cliente, seja diretamente no código ou em arquivos de configuração. No entanto, essa prática não é diretamente aplicável quando a inicialização do serviço cliente ocorre antes da implantação do provedor em um ambiente de nuvem, uma vez que o endereço do provedor é conhecido apenas após sua implantação. É preciso algum procedimento que possibilite que a referência ao endereço do provedor seja alterada no cliente em tempo de execução.

A solução por nós adotada para possibilitar a ligação dinâmica entre serviços envolve a criação de uma operação padronizada nos serviços clientes e na descrição arquitetural das dependências. Cada cliente implementa uma operação denominada \emph{setInvocationAddress}, que recebe como argumentos o papel do provedor e o endereço de um serviço que implemente esse papel. Isso quer dizer que tudo o que o cliente precisa saber em tempo de projeto são os papéis de seus provedores, como, por exemplo, um serviço de supermercado que precisa de um provedor para um serviço de entrega. A descrição arquitetural da coreografia deve definir quais serviços na coreografia podem desempenhar os papeis requisitados pelos serviços clientes. Por exemplo, em uma coreografia, o serviço MaisRapido pode ser o serviço de entrega do serviço de supermercado WillMart. Nesse exemplo, o Enactment Engine irá invocar a operação setInvocationAddress(entrega, http://192.168.56.107:8080/maisrapido.com/ws/) do serviço WillMart. Na solução apresentada, a ``inteligência'' em determinar quais serviços satisfazem as necessidades de outros serviços está em uma camada acima do Enactment Engine.

\section{Interface do \ee}
\label{sec:interface}

Os sistemas externos ao Enactment Engine utilizam suas funcionalidades por meio da API REST exposta pelo componente Choreography Deployer, que é descrita nesta subseção. Por se tratar de uma API REST, o cliente pode ser implementado em qualquer linguagem e ambiente que possua alguma biblioteca HTTP. Também disponibilizamos um cliente na forma de uma biblioteca na linguagem Java, tornando o uso do Enactment Engine ainda mais simples para os usuários da linguagem Java, atualmente uma das mais utilizadas do mercado. Seguimos agora listando as operações disponíveis. 

\begin{description}

\item [Criar coreografia:]

Descrição: registra a especificação de uma coreografia no Choreography Deployer. Essa especificação é a descrição arquitetural da coreografia, estruturada de acordo com a classe ChorSpec. Esa operação não realiza a encenação da coreografia.

%Requisição:
%URI: choreographydeployer/chors
%Método: POST
%Corpo: representação XML da classe ChorSpec.
%
%Resposta em caso de sucesso:
%Código de estado: 201 CREATED
%Cabeçalho ?location?: choreographydeployer/chors/{id} 
%
%Respostas em caso de falha:
%400 BAD REQUEST
%500 INTERNAL SERVER ERROR

{\small
\begin{tabular}{|c|c|c|c|}
\hline 
\itshape{Método HTTP} & \itshape{URI} & \itshape{Corpo da requisição} & \itshape{Respostas} \\ 
\hline 
POST & /chors & 

\begin{minipage}{2in}
Representação XML \\ de \textsf{ChorSpec}\\ 
(ver Listagem \ref{lst:chor_spec_xml})
\end{minipage} 
&

\begin{minipage}{2in}
\begin{verbatim}

201 CREATED
location = "/chors/{id}"

400 BAD REQUEST

500 ERROR

\end{verbatim}
\end{minipage} 
\\ 
\hline 
\end{tabular} 
}

\item [Obter coreografia:]

Obtém informações sobre uma coreografia registrada no Choreography Deployer. Essas informações se referem à especificação da coreografia e ao estado da implantação de seus serviços, como os nós em que os serviços foram implantados, no caso de a implantação já ter sido realizada.

%Requisição:
%URI: choreographydeployer/chors/{id}
%Método: GET
%
%Resposta em caso de sucesso:
%Código de estado: 200 OK
%Cabeçalho ?location?: choreographydeployer/chors/{id} 
%Corpo: representação em XML da classe Choreography. 
%
%Respostas em caso de falha:
%400 BAD REQUEST
%404 NOT FOUND
%500 INTERNAL SERVER ERROR

{\small
\begin{tabular}{|c|c|c|c|}
\hline 
\itshape{Método HTTP} & \itshape{URI} & \itshape{Corpo da requisição} & \itshape{Respostas} \\ 
\hline 
GET & /chors/\{id\} & - &
\begin{minipage}{2in}
\begin{verbatim}

200 OK
location = "/chors/{id}"
Corpo: 
\end{verbatim}
Representação XML \\ de \textsf{Choreography}\\ 
(ver Listagem \ref{lst:chor_xml})

\begin{verbatim}
400 BAD REQUEST

404 NOT FOUND

500 ERROR

\end{verbatim}
\end{minipage} 
\\ 
\hline 
\end{tabular}
}

\item [Encenar coreografia:]

Descrição: realiza a encenação de uma coreografia já registrada no Choreography Deployer. Ao fim do processo, detalhes do resultado da implantação são retornados na representação XML da coreografia. A implementação dessa operação deve possuir duas importantes propriedades: 1) a falha na encenação de parte da coreografia não deve interromper o encenação do resto da coreografia; 2) a operação deve ser \emph{idempotente}, ou seja, uma nova requisição para a encenação da mesma coreografia não deve tentar implantar os serviços já implantados, mas somente aqueles cujas implantações falharam na última execução. Para que serviços sejam atualizados, é preciso utilizar um novo valor no atributo ``versão'' da especificação do serviço.

%Requisição:
%URI: choreographydeployer/chors/{id}/enactment
%Método: POST
%
%Resposta em caso de sucesso:
%Código de estado: 200 OK
%Cabeçalho ?location?: choreographydeployer/chors/{id} 
%Corpo: representação em XML da classe Choreography. 
%
%Respostas em caso de falha:
%400 BAD REQUEST
%404 NOT FOUND
%500 INTERNAL SERVER ERROR

{\small
\begin{tabular}{|c|c|c|c|}
\hline 
\itshape{Método HTTP} & \itshape{URI} & \itshape{Corpo da requisição} & \itshape{Respostas} \\ 
\hline 
POST & /chors/\{id\}/enactment & - &
\begin{minipage}{2in}
\begin{verbatim}

200 OK
location = "/chors/{id}"
Corpo: 
\end{verbatim}
Representação XML \\ de \textsf{Choreography}\\ 
(ver Listagem \ref{lst:chor_xml})

\begin{verbatim}
400 BAD REQUEST

404 NOT FOUND

500 ERROR

\end{verbatim}
\end{minipage} 
\\ 
\hline 
\end{tabular} 
}

\item [Atualizar coreografia:]

Registra uma nova versão de uma coreografia no Choreography Deployer. Os serviços atualizados na nova versão da coreografia devem possuir um novo número de versão em suas especificações. Essa operação, assim como a criação da coreografia, não encena a nova coreografia. Para isso, é preciso invocar novamente a operação de encenação.

%Requisição:
%URI: choreographydeployer/chors/{id}
%Método: PUT
%Corpo: representação em XML da classe ChorSpec
%
%Resposta em caso de sucesso:
%Código de estado: 200 OK
%Cabeçalho ?location?: choreographydeployer/chors/{id} 
%Corpo: representação em XML da classe Choreography. 
%
%Respostas em caso de falha:
%400 BAD REQUEST
%404 NOT FOUND
%500 INTERNAL SERVER ERROR

{\small
\begin{tabular}{|c|c|c|c|}
\hline 
\itshape{Método HTTP} & \itshape{URI} & \itshape{Corpo da requisição} & \itshape{Respostas} \\ 
\hline 
PUT & /chors/\{id\} & 

\begin{minipage}{2in}
Representação XML \\ de \textsf{ChorSpec}\\ 
(ver Listagem \ref{lst:chor_spec_xml})
\end{minipage} 
&
\begin{minipage}{2in}
\begin{verbatim}

200 OK
location = "/chors/{id}"
Corpo: 
\end{verbatim}
Representação XML \\ de \textsf{Choreography}\\ 
(ver Listagem \ref{lst:chor_xml})

\begin{verbatim}
400 BAD REQUEST

404 NOT FOUND

500 ERROR

\end{verbatim}
\end{minipage} 
\\ 
\hline 
\end{tabular} 
}


\end{description}


\section{Pontos de extensão}
\label{sec:extensao}

Para lidar com as particularidades do ambiente de cada organização, o Enactment Engine fornece alguns pontos de extensão. Esses pontos de extensão são classes que desenvolvedores devem escrever na linguagem Java e que, de acordo com as configurações do sistema, poderão ser executadas por nossa plataforma.

\begin{description}

\item [CloudProvider:] 

Implementando a interface CloudProvider é possível o suporte a novas plataforma de computação em nuvem. Atualmente nossa implementação suporta o serviço EC2 do AWS e o OpenStack.

\begin{lstlisting}[frame=trbl, label=lst:cloud_provider, caption=Interface CloudProvider]
/**
 * Provides access to cloud service functions to create nodes on the cloud. 
 * 
 * Each specific provider (e.g. AmazonWS) must have an implementing class of this interface.
 * 
 * 
 */
public interface CloudProvider {

	public String getproviderName();
	
	public Node createNode(Node node) throws RunNodesException;

	public Node getNode(String nodeId) throws NodeNotFoundException;

	public List<Node> getNodes();

	public void destroyNode(String id) throws NodeNotDestroyed, NodeNotFoundException;

	public Node createOrUseExistingNode(Node node) throws RunNodesException;

}
\end{lstlisting}


\item [NodeSelector:]

A implementação da interface NodeSelector define uma nova política de alocação de serviços em nós da nuvem, que pode levar em conta os requisitos não-funcionais do serviço e propriedades dos nós à disposição.

\begin{lstlisting}[frame=trbl, label=lst:node_selector, caption=Interface NodeSelector]
/**
 * Selects a node to apply a given configuration
 * 
 * The selection can consider functional requirements, which is provided by config.name and non-functional requirements, which is provided by config.resourceImpact
 * Implementing classes must receive a CloudProvider
 * 
 * @author leonardo
 *
 */
public interface NodeSelector {

	public Node selectNode(Config config);
}
\end{lstlisting}

Formas similares dessa funcionalidade são também utilizadas em estudos já apresentados na seção de trabalhos relacionados.  O trabalho de Magee e Kramer~\cite{Magee1997Corba} apresenta a seleção de nós em função da utilização de CPUs nos nós existentes, não havendo possibilidade de utilização de outros critérios, como memória, disco, custo etc. Nos sistemas apresentados por Dolstra et al.~\cite{Dolstra2005Configuration} e Balter et al.~\cite{Balter1998Olan} é preciso que a distribuição dos serviços seja especificada com o uso dos IPs das máquinas nas quais os serviços devem ser implantados, o que não é possível em um ambiente de nuvem. Por fim, o \emph{broker} apresentado por Watson et al. é o componente que mais se assemelha ao nosso NodeSelector, pois os autores deixam claro que várias implementações diferentes são possíveis, considerando-se diferentes tipo de requisitos e diferentes fontes de monitoramento. Como a escolha é feita em tempo de execução do serviço, seria também possível uma seleção que independa de IPs estabelecidos em tempo de projeto. No entanto, os autores não explicam como os usuários de seu sistema, os provedores de infraestrutura, deveriam proceder para criar seus próprios \emph{brokers} personalizados.

Para avançar em relação às limitações dos trabalhos anteriormente citados,  consideramos como requisitos principais a dinamicidade do ambiente de nuvem, que nos impede de conhecer os IPs das máquinas em tempo de configuração, bem como a flexibilidade para que cada organização determine os requisitos de distribuição dos serviços.

\item [Receitas:]

Um serviço pode ser distribuído por diferentes tipos de artefatos implantáveis, como em um JAR ou em um WAR, por exemplo. Como existem muitas outras opções, é preciso que esse seja um ponto de flexibilidade. Para cada tipo de distribuição, pode-se escrever uma receita Chef que sabe como instalar e executar o serviço. Como essas receitas são criadas dinamicamente com base em modelos pré-definidos e propriedades do serviço a ser implantado, é preciso também implementar a interface RecipeBuilder para criar uma nova extensão correspondente a um novo tipo de artefato implantável.

\begin{lstlisting}[frame=trbl, label=lst:recipe_builder, caption=Interface RecipeBuilder]
public interface RecipeBuilder {
	
 /**
  * Uses the template to create a new recipe according to service specification.
  * This new recipe can be used by Chef to deploy the service.
  * 
  * @param service
  * @return
  */
 public Recipe createRecipe(ServiceSpec serviceSpec);
}
\end{lstlisting}

\item [ContextSender:]

A ligação entre serviços de uma coreografia depende da passagem de endereços que é feita do Choreography Deployer para os serviços. Para isso, o Choreography Deployer precisa invocar a operação setInvocationAddres dos serviços. A implementação de tal invocação se dará de forma diferente se o serviço for SOAP ou REST. A implementação da interface ContextSender possibilita ao Choreography Deployer realizar a invocação da operação setInovcationAddress em serviços de outras tecnologias (JMS e CORBA por exemplo). Nota-se que para cada um desses tipos de serviços adicionados pelo usuário, é preciso criar uma convenção para a assinatura sintática da operação setInvocationAddres.

\begin{lstlisting}[frame=trbl, label=lst:context_sender, caption=Interface ContextSender]
public interface ContextSender {
	
 /**
  * Calls setInvokationAddress operation on service in the serviceEndpoint.
  * So, the service in endpoint will know that its
  * partner with partnerRole is realized by partnerEndpoint.
  * 
  * @param serviceEndpoint
  * @param partnerRole
  * @param partnerEndpoint
  * @throws ContextNotSentException if context was not successfully set
  */
  public void sendContext(String serviceEndpoint, String partnerRole, String partnerEndpoint) throws ContextNotSentException;

}
\end{lstlisting}

\end{description}

\section{Aspectos de grande escala}
\label{sec:solucao_grande_escala}

\fabio{Fazer uma tabela de características, mostrando quais suportamos e quais não. Se der, comparar com outros trabalhos}

Na seção ``Computação em Grande Escala'' abordamos alguns desafios, práticas e princípios necessários para a construção de sistemas de grande escala. Dado que nossa arquitetura deve possibilitar a implantação de sistemas de grande escala, relatamos nesta seção quais práticas levamos em consideração na definição de nossa arquitetura, assim como limitações de nossa arquitetura devido a outras práticas não adotadas.

O princípio adotado mais importante é o de fornecer uma ferramenta que possibilite um processo totalmente automatizado para a implantação de coreografias. Contudo, cabe ressaltar que um processo totalmente automatizado não depende apenas do Enactment Engine. Por exemplo, o Enactment Engine deve receber como entrada um XML que descreva a coreografia. Espera-se que esse XML seja gerado automaticamente de alguma forma, mas essa é uma responsabilidade além do escopo de nossa proposta, de forma que na prática nosso sistema também funcionaria com um XML gerado manualmente. No contexto do projeto CHOReOS, essa especificação é gerada por um processo automático de síntese que recebe como entrada a especificação da coreografia na notação BPMN2~\cite{Autili2013Synthesis}.

Buscando a simplicidade, adotamos REST como o estilo de serviços oferecidos pela nossa arquitetura. Isso evita algum overhead que seria gerado pelo SOAP, possibilita a utilização de caches gerados pelos servidores web e possibilita que testes simples sejam realizados com ferramentas integradas ao navegador, como o Poster, um plugin do Firefox para requisições HTTP.

Quando possível, privilegiamos o projeto de serviços sem estado, que oferecessem APIs com operações idempotentes e assíncronas. Um exemplo é a operação de encenação de uma coreografia. Pela API, caso o Enactment Engine receba duas vezes a instrução de encenar uma mesma coreografia, referenciada por um ID, o Enactment Engine pode continuar a encenação em andamento, em vez de começar toda a operação novamente. Além disso, a encenação é uma operação muito longa, de modo que seria muito difícil para um cliente distinguir um timeout de uma falha. Por isso pretendemos projetar uma API em que a encenação de uma coreografia seja uma operação assíncrona.

A tolerância a falhas se dá principalmente por considerar que os seguintes eventos são passíveis de erros: comunicação com sistemas externos, por exemplo, Chef e AWS EC2, assim como a implantação de serviços da coreografia. No entanto, simplificaremos o projeto e a implementação ao supor que a comunicação entre os componentes de nossa plataforma (Enactment Engine, Service Deployer e Node Pool Manager) seja confiável. 

O conceito de degradação suave é preciso ser compartilhado com os serviços da coreografia, pois um serviço tem que saber fornecer uma resposta adequada caso uma de suas dependências esteja indisponível. Do ponto de vista do Enactment Engine, tudo o que é preciso fazer é ter ciência de quais serviços estão indisponíveis e informar isso para os clientes. A degradação suave cabe ao Enactment Engine quando os serviços dos quais ele depende, Chef e cloud gateway, estão indisponíveis.

O problema de haver um ponto único de falha é reduzido quando estamos em um cenário com várias organizações. Dessa forma, caso um Service Deployer esteja indisponível, é possível para um Enactment Engine utilizar um Service Deployer de outra organização. Claro que essa possibilidade fica condicionada às políticas das organizações de aceitarem que seus serviços sejam implantados na infraestrutura de outras organizações, assim como em permitir que serviços de outras organizações sejam implantados em suas próprias infraestruturas. Caso um Enactment Engine falhe, há a opção de se utilizar outro Enactment Engine. Mas para que o segundo continue a operação no ponto deixado pelo primeiro, é preciso um compartilhamento prévio de dados que não será abordado neste trabalho. 

A duplicação de dados ou de componentes não será abordada neste trabalho. Dessa forma, cuidados que a camada de aplicação deve ter com a inconsistência dos dados não serão necessários. Por não haver duplicação de componentes, também não será possível o balanceamento de carga. Acreditamos que esses sejam importantes aspectos para uma expansão futura do sistema.

Neste trabalho não abordaremos a problemática da evolução do nosso próprio sistema. No entanto, esperamos que nossa arquitetura possa dar suporte à evolução das coreografias implantadas, mesmo que de forma simples, ou seja, sem garantia da correta terminação das operações em andamento no momento da atualização. Consideramos esse ponto importante, mas fugindo do nosso escopo por merecer um trabalho dedicado somente a essa questão.

\section{Implementação atual}
\label{sec:impl_atual}

\section{Avaliação preliminar de escalabilidade}
\label{sec:avaliacao}



